#!meta

{"kernelInfo":{"defaultKernelName":"csharp","items":[{"aliases":[],"languageName":"csharp","name":"csharp"}]}}

#!markdown

# Практическая работа №6. Изучение производительности потоко-безопасных очередей.

**Цель:** Определить лучшую потоко-безопасную коллекцию для выполнения интенсивной обработки входящих сообщений.

**Результаты:** После выполнения работы Вы сможете:
1. Назвать оптимальную коллекцию для обработки большого количества сообщений.
2. Изучите примтив синхронизации Условная переманная.


**Материалы для самостоятельного изучения**.
1. [Потоко-безопасные коллекции](https://learn.microsoft.com/en-us/dotnet/standard/collections/thread-safe/)
2. Условные переменные Глава 5 п.5.1. книги Г. Эндрюс Основы многопоточного, параллельного и распределенного программирования
3. [Одна из реализаций условных переменных на .Net](https://learn.microsoft.com/ru-ru/dotnet/api/system.threading.manualresetevent?view=net-8.0)

## Задание.
Исслдеовать производительность BlockingCollection и ConcurrentQueue в сравнении с непотокоабезопасной очередью.

Для каждой потоко-безопасной очереди необходимо реализовать 2 потока: один записывает объект в очередь, а другой - читает объект из очереди.
Для непотокобезопасной очереди реализовать два цикла - записи миллиона объектов в очередь и чтение миллиона объектов из очереди.

Необходимо определить два промежутка времени:
- время за которое поток или цикл обработает миллион объектов
- время, необходимое на запись и чтение миллиона объектов из очреди.

Сделать десять замеров по каждой коллекции. Все замеры показать на графике.

Записать в ноутбуке вывод - какая и потоко-безопасных коллекций эффективнее. И выразить в процентах - скорость самой быстрой поток-безопасной коллекции по сравнению с обычной очредью.

**Указание**.
1. Необходимо исключить из замеров время, необходимое для запуска и остановки потоков, то есть посчитать чистое время, необходимое для обработки объектов.
Для этого следует использовать условные события, которые позволят убедиться, что оба потока запустились и готовы читать и писать объекты и только потом запускать таймер.
2. Для итогового вывода сравнивать усредненные значения.

#!csharp

#r "nuget:ScottPlot, 5.0.35"

using System;
using System.Collections.Generic;
using System.Collections.Concurrent;
using System.Threading;
using System.Threading.Tasks;
using System.Diagnostics;
using Microsoft.DotNet.Interactive.Formatting;

Formatter.Register(typeof(ScottPlot.Plot), (plot, writer) => 
    writer.Write(((ScottPlot.Plot)plot).GetImageHtml(600, 800)), HtmlFormatter.MimeType);

#!markdown

# Непотокобезопасная очередь

#!csharp

var stopwatch = new Stopwatch();
var ticksList = new List<long>();

for (int j = 0; j < 10; j++)
    {
        var queue = new Queue<int>();
        stopwatch.Restart();
        for (int i = 0; i < 1000000; i++)
        {
            queue.Enqueue(i);
        }

        while (queue.Count > 0)
        {
            queue.Dequeue();
        }

        stopwatch.Stop();
        ticksList.Add(stopwatch.ElapsedTicks);
    }

Console.WriteLine($"Average: {ticksList.Average()} Min: {ticksList.Min()}");

ScottPlot.Plot plt = new();
plt.Add.Scatter(Enumerable.Range(1, 10).ToArray(), ticksList.ToArray());
plt

#!markdown

# ConcurrentQueue

#!csharp

var stopwatch = new Stopwatch();
var eventHandler = new ManualResetEvent(false);
var ticksList = new List<long>();

for (int k = 0; k < 10; k++)
{
    var concurrentQueue = new ConcurrentQueue<int>();

    var writerThread = new Thread(() =>
    {
        eventHandler.WaitOne();
        stopwatch.Start();
        for (int i = 0; i < 1000000; i++)
        {
            concurrentQueue.Enqueue(i);
        }
    });

    var readerThread = new Thread(() =>
    {
        eventHandler.Set();
        int item;
        while (concurrentQueue.TryDequeue(out item));
        stopwatch.Stop();
    });

    writerThread.Start();
    readerThread.Start();

    writerThread.Join();
    readerThread.Join();

    ticksList.Add(stopwatch.ElapsedTicks);
    stopwatch.Reset();
    eventHandler.Reset();
}

Console.WriteLine($"Average: {ticksList.Average()} Min: {ticksList.Min()}");

ScottPlot.Plot plt = new();
plt.Add.Scatter(Enumerable.Range(1, 10).ToArray(), ticksList.ToArray());
plt

#!markdown

# BlockingCollection

#!csharp

var stopwatch = new Stopwatch();
var eventHandler = new ManualResetEvent(false);
var ticksList = new List<long>();

for (int k = 0; k < 10; k++)
{
    var blockingCollection = new BlockingCollection<int>();

    var writerThread = new Thread(() =>
    {
        eventHandler.WaitOne();
        stopwatch.Start();
        for (int i = 0; i < 1000000; i++)
        {
            blockingCollection.Add(i);
        }
        blockingCollection.CompleteAdding();
    });

    var readerThread = new Thread(() =>
    {
        eventHandler.Set();
        foreach (var item in blockingCollection.GetConsumingEnumerable());
        stopwatch.Stop();
    });

    writerThread.Start();
    readerThread.Start();

    writerThread.Join();
    readerThread.Join();

    ticksList.Add(stopwatch.ElapsedTicks);
    stopwatch.Reset();
    eventHandler.Reset();
}

Console.WriteLine($"Average: {ticksList.Average()} Min: {ticksList.Min()}");

ScottPlot.Plot plt = new();
plt.Add.Scatter(Enumerable.Range(1, 10).ToArray(), ticksList.ToArray());
plt

#!markdown

# Результаты в тиках
1. Непотокобезопасная очередь - Average: 148836,1 Min: 66263
2. ConcurrentQueue - Average: 135118,3 Min: 115567       
3. BlockingCollection - Average: 1699540,3 Min: 1153911         

#!markdown

# Итог
1. Самая эффективная - ConcurrentQueue
2. Она быстрее обычной очереди (относительно срединх тиков) примерно на 10% 
